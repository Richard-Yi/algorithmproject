# 本章讨论

- 如何估计一个程序所需要的时间
- 如何讲一个程序的运行时间从天或年降低到秒甚至更少
- 粗心使用递归的后果
- 将一个数字撑得到其幂，以及计算两个数最大公因数的非常有效的方法

# 2.1 数学基础 
1. 提出了大O表示法来表示运行时间 T(N)。
# 2.2 模型 - 无笔记
# 2.3 要分析的问题
  
1. 要分析的最重要的资源就是运行时间 `T(N)` -- 算法(时间)复杂度；
定义了两个函数T<sub>avg</sub>(N)和T<sub>worst</sub>(N)分别为输入量`N`所花费的平均运行时间和最坏情况下运行时间。

# 2.4 运行时间计算

1. 为了简化分析，采纳如下约定：不存在特定的时间单位。
2. 分析时抛弃低阶项，计算大`O`运行时间，由于大`O`是一个上界，所以绝不要低估程序的运行时间。
程序可能提前结束，但绝不可能错后。

## 2.4.2 一般法则

1. 法则1 - `for` 循环：一个`for`循环运行时间至多是**该循环内部语言运算时间**乘以**迭代次数**

2. 法则2 - 嵌套的`for` 循环：从里向外分析这些循环。在一组嵌套循环内部的一条语句的总运行时间为**该语句的运行时间**乘以**该组所有for循环的大小**的城西

3. 法则3 - 顺序语句： 将各个语句的运行时间求和即可，忽略低阶项。

4. 法则4 - `if/else`语句

```java
if (condition) {
    S1
} else {
    S2
}
```

按照S1、S2中运算时间大的那个来计算。

# 2.4.3 最大子列和问题的求解

通过对这个问题的四种不同算法展示了算法的分析过程和优化过程，四种算法的实现在`Week1Test1.java`中有实现代码。不一一展示。

# 2.4.4 运算时间中的对数

1. 某些分治算法将以*O(NlogN)*时间运行。
2. 对数最常出现的规律可概括为下列一般法则：如果一个算法用常数时间*(O(1))*将问题的大小削减为其一部分（通常是1/2），那么该算法就是*O(NlogN)*。
3. 书中举了3个*O(NlogN)*的例子：
> 3.1 binarySearch 二分法查找 代码很简单，不赘述
> 
> 3.2 欧几里得算法 -- 计算两个整数的最大公因数，
> 
> 估算整个算法的长度依赖于确定余数序列究竟有多长。余数序列最多为原始值的一半。
> 
> 3.3 幂运算 看具体代码便可发现，使用一种递归算法可以简化幂运算。
> 
> 计算x<sup>N</sup>时，N<=1是这个递归的基准条件。若N为偶数，x<sup>N</sup> = x<sup>N/2</sup> · x<sup>N/2</sup>；如果N为奇数，x<sup>N</sup> = x<sup>(N-1)/2</sup>
> 
```java

/**
 * 欧几里得算法
 */
public static long gcd(long m, long n) {
    while (n!=0) {
        long rem = m % n;
        m = n;
        n = rem;
    }
    return m;
}
```

```java

/**
 * 幂运算
 */
public static long pow(long x, int n) {
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return x;
    }
    if ( isEven(n) ) {
        return pow(x * x, n / 2);
    } else {
        return pow(x * x, n / 2) * x;
    }
}
```

# 小结

本章对如何分析程序的复杂性给出了一些提示。算是算法之旅的入门第一步吧。
  